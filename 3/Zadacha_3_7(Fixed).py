# Лабораторная работа №3.Задание №7.Вариант 10.
# Вычисляем (Yn)^p-1 (Алгоритм быстрого возведения в степень)
def func(x1, n1):
    # При n = 0, возвращаем 1
    if n1 == 0:
        return 1
    # При нечётном n, понижаем степень на 1
    elif n1 % 2 == 1:
        return func(x1, n1-1) * x1
    else:
        # При чётном n, делим степень на 2
        x2 = func(x1, n1 // 2)
        return x2**2
# Функция вычисления корня и количества итераций
def krP(x, p, chag):
    # Первая итерация в особом порядке
    x1 = x
    # Вычисление на основе формулы Ньютона
    Y = (1/p)*((p-1)*x1 + (x / func(x1, p-1)))
    n = 1
    # Пока точность вычисления больше, либо равна |Yn+1 - Yn|, то высисляю
    while abs(Y - x1) > chag:
        x1 = Y
        # Вычисление на основе формулы Ньютона
        Y = (1/p)*((p-1)*x1 + (x / func(x1, p-1)))
        # Cчетчик итераций
        n += 1
    return x1, n
# Ввод данных
x = float(input("Введите число X: "))
p = int(input("Введите степень P: "))
# Шаг 10^-1 или 0.1
chag = 0.1
# Параметр для точности от 10^(-2) до 10^(-6). Всего 5 итераций.
for i in range(5):
    # Изменение шага
    chag /= 10
    # Отыскание корня P-й степени цикла с параметром для точности
    res, n = krP(x, p, chag)
    # Вывод результата точность, корень, число итераций
    print("Точность:{:f}  Корень:{:f} Числ.итераций: {}".format(chag, res, n))
